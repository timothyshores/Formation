/*

❓ PROMPT
Given a string that contains exactly 1 pair of parentheses, compute recursively a new string made of only the parentheses and their contents, so "xyz(abc)123" yields "(abc)".

Example(s)
parenBit("xyz(abc)123") == "(abc)"
parenBit("x(hello)") == "(hello)"
parenBit("(xy)1") == "(xy)"

Notes
- The input can be be an empty string 
- The parentheses can either contain or not contain characters in the parenthesis

🔎 EXPLORE
List your assumptions & discoveries:

Insightful & revealing test cases:

🧠 BRAINSTORM
What approaches could work?
Algorithm 1: 
Time: 
Space: 

📆 PLAN
Outline of algorithm #:
🛠️ IMPLEMENT
function parenBit(word) {
def parenBit(word: str) -> str:

🧪 VERIFY
Run tests. Methodically debug & analyze issues.

*/
