/*

â“ PROMPT
Given a string that contains exactly 1 pair of parentheses, compute recursively a new string made of only the parentheses and their contents, so "xyz(abc)123" yields "(abc)".

Example(s)
parenBit("xyz(abc)123") == "(abc)"
parenBit("x(hello)") == "(hello)"
parenBit("(xy)1") == "(xy)"

Notes
- The input can be be an empty string 
- The parentheses can either contain or not contain characters in the parenthesis

ğŸ” EXPLORE
List your assumptions & discoveries:

Insightful & revealing test cases:

ğŸ§  BRAINSTORM
What approaches could work?
Algorithm 1: 
Time: 
Space: 

ğŸ“† PLAN
Outline of algorithm #:
ğŸ› ï¸ IMPLEMENT
function parenBit(word) {
def parenBit(word: str) -> str:

ğŸ§ª VERIFY
Run tests. Methodically debug & analyze issues.

*/
