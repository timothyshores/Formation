/*
â“ PROMPT
Given an array, write a recursive functions to find the index of the maximum element in an array. If there's a tie-breaker, return the first occurrence.

Example(s)
findMaxIndex([12, 1234, 45, 67, 1]) == 1
findMaxIndex([10, 20, 30]) == 2
findMaxIndex([8, 6, 7, 5, 3, 7]) == 0

ðŸ”Ž EXPLORE
State your assumptions & discoveries:

Create examples & test cases:

console.log(findMaxIndex([0]) === 0);
console.log(findMaxIndex([11]) === 0);
console.log(findMaxIndex([-1]) === 0);
console.log(findMaxIndex([15, 11]) === 0);
console.log(findMaxIndex([30, 20, 10]) === 0);
console.log(findMaxIndex([30, 99, 10]) === 1);
console.log(findMaxIndex([10, 20, 30]) === 2);
console.log(findMaxIndex([20, 10, 30]) === 2);
console.log(findMaxIndex([10, 10, 10, 10]) === 0);
console.log(findMaxIndex([10, 20, 30, 10]) === 2);
console.log(findMaxIndex([8, 6, 7, 5, 3, 7]) === 0);
console.log(findMaxIndex([-10, -5, -3, -30]) === 2);
console.log(findMaxIndex([15, 11, 12, 13, 14]) === 0);
console.log(findMaxIndex([12, 1234, 45, 67, 1]) === 1);
console.log(findMaxIndex([15, 17, 16, 12, 13, 14]) === 1);

ðŸ§  BRAINSTORM
What approaches could work? Consider data structures or algorithmic patterns.
Analyze the space & time complexity.
Approach 1:
Time: O()
Space: O()

ðŸ“† PLAN
High-level outline of approach #: 

ðŸ› ï¸ IMPLEMENT */
const findMaxIndex = (arr) => {};

/*
ðŸ§ª VERIFY
Run your examples & test cases.
Methodically analyze and debug issue(s).
*/
